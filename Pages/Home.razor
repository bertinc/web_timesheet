@page "/"
@using System.Net.Http.Json
@using System.Threading.Tasks
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JsRuntime
@using TimeSheet.Models

<PageTitle>Home</PageTitle>

<!-- Main application container using flexbox layout -->
<div class="app">
    <!-- Page header with branding -->
    <header class="header">Time Sheet 2.0</header>

    <!-- Main layout container (flexbox) with toolbar and content area -->
    <div class="main">
        <!-- Left sidebar toolbar containing filters and form inputs for adding new entries -->
        <aside class="toolbar">
            <nav>
                <ul>
                    <!-- Navigation links to manage master data -->
                    <li><a href="categories">Edit Categories</a></li>
                    <li><a href="companies">Edit Companies</a></li>
                    <li><a href="projects">Edit Projects</a></li>
                    
                    <!-- Date range filter for search with quick buttons -->
                    <li>
                        <label for="start">Search Range:</label>
                        <input id="start" type="date" @bind-value="start" @bind-value:after="OnStartDateChanged" />
                        - <input id="end" type="date" @bind-value="end" @bind-value:after="OnEndDateChanged" />
                        <!-- Quick range selection buttons -->
                        <button @onclick="SetToday" style="margin-left: 5px;">Today</button>
                        <button @onclick="SetCurrentWeek" style="margin-left: 5px;">Week</button>
                        <button @onclick="SetCurrentMonth" style="margin-left: 5px;">Month</button>
                    </li>
                    
                    <!-- Date input for new entry -->
                    <li>
                        <label style="float:left" for="date">Day:</label>
                        <input id="date" type="date" @bind="date" @bind:after="OnDateChanged" />
                    </li>
                    
                    <!-- Time input with "Now" button for current time (snapped to 15 minutes) -->
                    <li>
                        <label style="float:left" for="time">Time:</label>
                        <input id="time" type="time" @bind="time" @bind:after="OnTimeChanged" />
                        <button @onclick="SnapToNow" style="margin-left: 5px;">Now</button>
                    </li>
                    
                    <!-- Hours duration input -->
                    <li>
                        <label style="float:left" for="hrs">Enter Hours:</label>
                        <input @ref="inputHours" id="hrs" type="number" min="0" max="24" step="0.25" @bind="hours" @bind:after="OnHoursChanged" />
                    </li>
                    
                    <!-- Comment/description textarea for new entry -->
                    <li>
                        <label for="cmt">Comment:</label>
                        <textarea id="cmt" rows="2" @bind="comment" @bind:after="OnCommentChanged" class="w-100"></textarea>
                    </li>
                    
                    <!-- Category selection dropdown -->
                    <li>
                        <label for="category">Category:</label>
                        <select id="category" @bind="selectedCategoryId" @bind:after="OnCategoryChanged">
                            <option value="0" selected>None</option>
                            @foreach (var c in categories.Categories ?? new List<Category>())
                            {
                                <option value="@c.Id">@c.Code</option>
                            }
                        </select>
                    </li>
                    
                    <!-- Company selection dropdown -->
                    <li>
                        <label for="company">Company:</label>
                        <select id="company" @bind="selectedCompanyId" @bind:after="OnCompanyChanged">
                            <option value="0" selected>None</option>
                            @foreach (var comp in companies.Companies ?? new List<Company>())
                            {
                                <option value="@comp.Id">@comp.Name</option>
                            }
                        </select>
                    </li>
                    
                    <!-- Project selection dropdown (filtered by selected company) -->
                    <li>
                        <label for="project">Project:</label>
                        <select id="project" @bind="selectedProjectId" @bind:after="OnProjectChanged">
                            <option value="0" selected>None</option>
                            @foreach (var proj in projects.Projects ?? new List<Project>())
                            {
                                @if (selectedCompanyId == 0 || proj.CompanyId == null || proj.CompanyId == selectedCompanyId)
                                {
                                    <option value="@proj.Id">@proj.Name</option>
                                }
                            }
                        </select>
                    </li>
                    
                    <!-- Billable checkbox -->
                    <li>
                        <label style="float:left; vertical-align:middle;" for="billable">Billable:</label>
                        <input id="billable" type="checkbox" @bind="billable" @bind:after="OnBillableChanged" />
                    </li>
                    
                    <!-- Details/notes textarea for new entry -->
                    <li>
                        <label for="details">Notes:</label>
                        <textarea id="details" rows="4" @bind="details" @bind:after="OnDetailsChanged" class="w-100"></textarea>
                    </li>
                    
                    <!-- Action buttons: Add entry and Download report -->
                    <li><button @onclick="AddEntry">Add Entry</button> <button @onclick="GetReport">Download Report</button></li>
                    
                    <!-- Report deadline information (previous month) -->
                    <li>
                        Report @DateTime.Now.AddMonths(-1).ToString("MMM") hours by @GetFirstTuesday(DateTime.Now).ToString("MMM dd")
                    </li>
                    
                    <!-- Report deadline information (current month) -->
                    <li>
                        Report @DateTime.Now.ToString("MMM") hours by @GetFirstTuesday(DateTime.Now.AddMonths(1)).ToString("MMM dd")
                    </li>
                </ul>
            </nav>
        </aside>

        <!-- Main content area displaying search results table -->
        <section class="content">
            <h3>Search Results</h3>
            
            <!-- Results table (displayed if entries exist) -->
            @if (SearchResults.Entries != null)
            {
                <table class="results_table" id="entries">
                    <!-- Table headers -->
                    <thead>
                        <tr>
                            <!-- ID column hidden <th>ID</th> -->
                            <th>Date</th>
                            <th>Start</th>
                            <th>End</th>
                            <th>Minutes</th>
                            <th>Description</th>
                            <th>Category</th>
                            <th>Company</th>
                            <th>Project</th>
                            <!-- Notes column hidden <th>Notes</th> -->
                            <th colspan="1">Actions</th>
                        </tr>
                    </thead>
                    
                    <!-- Table body - loops through all entries -->
                    <tbody>
                        @foreach (var entry in SearchResults.Entries)
                        {
                            <!-- Entry row (clickable to open edit modal) -->
                            <tr @onclick="@(() => OpenEditModal(entry))" style="cursor: pointer;">
                                <!-- ID column hidden <td>@entry.Id</td> -->
                                <td>@entry.EntryDate</td>
                                <td>@FormatTime(entry.StartTime)</td>
                                <td>@FormatTime(entry.EndTime)</td>
                                <td>@entry.DurationMinutes</td>
                                <td class="small">@entry.Description</td>
                                <td>@entry.CategoryCode</td>
                                <td>@entry.CompanyName</td>
                                <td>@entry.ProjectCode</td>
                                <!-- Notes column hidden <td class="small">@entry.Notes</td> -->
                                <!-- Remove button (prevents row click from triggering edit) -->
                                <td><button @onclick="@(() => RemoveEntry(@entry.Id))" @onclick:stopPropagation="true">Remove</button></td>
                            </tr>
                        }
                        
                        <!-- Total hours and pay footer row -->
                        @if (HoursPayResults != null)
                        {
                            <tr>
                                <td colspan="100">Total Hours: @HoursPayResults.Hours for Pay: @HoursPayResults.Pay.ToString("C")</td>
                            </tr>
                        }
                    </tbody>
                </table>
            }
        </section>
    </div>

    <!-- Footer with status message -->
    <footer class="footer">
        <label hidden="@hide_it">@label_text</label>
    </footer>
</div>

<!-- Edit Entry Modal -->
@if (showEditModal)
{
    <!-- Modal backdrop (clickable to close) -->
    <div class="modal-backdrop" @onclick="CloseEditModal">
        <!-- Modal content container -->
        <div class="modal-content" @onclick:stopPropagation="true">
            <h3>Edit Entry #@editingEntry.Id</h3>
            
            <!-- Modal body with form fields -->
            <div class="modal-body">
                <!-- Entry date field -->
                <div class="form-group">
                    <label for="edit-date">Day:</label>
                    <input id="edit-date" type="date" @bind="editingEntry.EntryDate" />
                </div>
                
                <!-- Entry start time field -->
                <div class="form-group">
                    <label for="edit-time">Start Time:</label>
                    <input id="edit-time" type="time" @bind="editingEntry.StartTime" />
                </div>
                
                <!-- Entry duration field (in minutes) -->
                <div class="form-group">
                    <label for="edit-minutes">Duration (minutes):</label>
                    <input id="edit-minutes" type="number" @bind="editingEntry.DurationMinutes" min="0" step="15" />
                </div>
                
                <!-- Entry description field -->
                <div class="form-group">
                    <label for="edit-description">Description:</label>
                    <textarea id="edit-description" rows="2" @bind="editingEntry.Description"></textarea>
                </div>
                
                <!-- Category selection field -->
                <div class="form-group">
                    <label for="edit-category">Category:</label>
                    <select id="edit-category" @bind="editingEntry.CategoryId">
                        <option value="0">None</option>
                        @foreach (var c in categories.Categories ?? new List<Category>())
                        {
                            <option value="@c.Id">@c.Code</option>
                        }
                    </select>
                </div>
                
                <!-- Company selection field -->
                <div class="form-group">
                    <label for="edit-company">Company:</label>
                    <select id="edit-company" @bind="editingEntry.CompanyId">
                        <option value="0">None</option>
                        @foreach (var comp in companies.Companies ?? new List<Company>())
                        {
                            <option value="@comp.Id">@comp.Name</option>
                        }
                    </select>
                </div>
                
                <!-- Project selection field -->
                <div class="form-group">
                    <label for="edit-project">Project:</label>
                    <select id="edit-project" @bind="editingEntry.ProjectId">
                        <option value="0">None</option>
                        @foreach (var proj in projects.Projects ?? new List<Project>())
                        {
                            <option value="@proj.Id">@proj.Name</option>
                        }
                    </select>
                </div>
                
                <!-- Billable checkbox field -->
                <div class="form-group">
                    <label for="edit-billable">Billable:</label>
                    <input id="edit-billable" type="checkbox" @bind="editingEntry.Billable" />
                </div>
                
                <!-- Notes field -->
                <div class="form-group">
                    <label for="edit-notes">Notes:</label>
                    <textarea id="edit-notes" rows="3" @bind="editingEntry.Notes"></textarea>
                </div>
            </div>
            
            <!-- Modal action buttons -->
            <div class="modal-footer">
                <button @onclick="SaveEditedEntry">Save</button>
                <button @onclick="CloseEditModal">Cancel</button>
            </div>
        </div>
    </div>
}

<!-- Delete Confirmation Modal -->
@if (showDeleteModal)
{
    <!-- Modal backdrop (clickable to cancel) -->
    <div class="modal-backdrop" @onclick="@CancelDelete">
        <!-- Modal content container -->
        <div class="modal-content" @onclick:stopPropagation="true">
            <h3>Confirm Delete</h3>
            
            <!-- Modal body with confirmation message -->
            <div class="modal-body">
                <p>Are you sure you want to delete this entry?</p>
                <p>This action cannot be undone.</p>
            </div>
            
            <!-- Modal action buttons -->
            <div class="modal-footer">
                <!-- Delete button (red warning color) -->
                <button @onclick="@ConfirmDelete" style="background-color: #e74c3c;">Delete</button>
                <!-- Cancel button -->
                <button @onclick="@CancelDelete">Cancel</button>
            </div>
        </div>
    </div>
}

@code {
    private ElementReference inputHours;
    private bool hide_it = true;
    private string label_text = "Some Text";
    private DateTime date = DateTime.Now.Date;
    private DateTime start = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1);
    private DateTime end = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1).AddMonths(1).AddDays(-1);
    private TimeOnly time = TimeOnly.FromDateTime(DateTime.Now.Date.AddHours(7));
    private float hours = 0;
    private bool billable = true;
    private string comment = string.Empty;
    private string details = string.Empty;
    private int entryIdToRemove = 0;
    
    private bool showEditModal = false;
    private EditEntryModel editingEntry = new EditEntryModel();
    
    private bool showDeleteModal = false;
    private string deleteItemName = string.Empty;
    private int deleteItemId = 0;
    
    private string api_base = "http://10.0.0.192:8001/";
    private string get_cats_endpont = "categories";
    private string get_comp_endpont = "companies";
    private string get_proj_endpont = "projects";
    private string get_entries_endpoint = "getentries";
    private string add_entry_endpoint = "addentry";
    private string update_entry_endpoint = "updateentry";
    private string remove_entry_endpoint = "removeentry";
    private string get_hours_pay_endpoint = "gethoursandpay";
    private string api_url = "http://10.0.0.192:8001/addrow";
    private CategoriesResponse categories = new CategoriesResponse();
    private CompaniesResponse companies = new CompaniesResponse();
    private ProjectsResponse projects = new ProjectsResponse();
    private GetEntriesResponse SearchResults = new GetEntriesResponse();
    private AddEntryResponse InsertResults = new AddEntryResponse();
    private GetHoursAndPayResponse HoursPayResults = new GetHoursAndPayResponse();
    // Selected category id from the <select>
    private int? selectedCategoryId;
    // Selected company id from the <select>
    private int? selectedCompanyId;
    // Selected project id from the <select>
    private int? selectedProjectId;

    // Set the code you want auto-selected here
    private string autoSelectCategoryCode = "DEV";
    private string autoSelectCompanyName = "Wasatch Photonics";

    private IJSObjectReference module;
    private const string FORM_STATE_KEY = "home_form_state";

    /// <summary>
    /// Initialization hook called when the component is first initialized.
    /// Loads the previously saved form state from sessionStorage.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        await LoadFormState();
    }

    /// <summary>
    /// Lifecycle method called after the component has been rendered.
    /// On first render, loads categories, companies, projects, and entries from the backend.
    /// Sets focus to the hours input field.
    /// </summary>
    /// <param name="firstRender">True if this is the first render, false on subsequent renders.</param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // execute conditionally for loading data, otherwise this will load
        // every time the page refreshes
        if (firstRender)
        {
            await GetCategories();
            await GetCompanies();
            await GetProjects();
            await inputHours.FocusAsync();
            await GetEntries();
            StateHasChanged();
        }
    }

    /// <summary>
    /// Fetches all categories from the backend API.
    /// Auto-selects the default category based on autoSelectCategoryCode if not already restored from state.
    /// </summary>
    public async Task GetCategories()
    {
        var resp = await Http.GetAsync(api_base + get_cats_endpont);
        if (resp.IsSuccessStatusCode)
        {
            categories = await resp.Content.ReadFromJsonAsync<CategoriesResponse>();

            // Auto-select category by code only if not already set from restored state
            if (!selectedCategoryId.HasValue || selectedCategoryId == 0)
            {
                selectedCategoryId = categories.Categories?
                    .FirstOrDefault(c => string.Equals(c.Code, autoSelectCategoryCode, StringComparison.OrdinalIgnoreCase))
                    ?.Id ?? 0;
            }
        }
    }

    /// <summary>
    /// Fetches all companies from the backend API.
    /// Auto-selects the default company based on autoSelectCompanyName if not already restored from state.
    /// </summary>
    public async Task GetCompanies()
    {
        var resp = await Http.GetAsync(api_base + get_comp_endpont);
        if (resp.IsSuccessStatusCode)
        {
            companies = await resp.Content.ReadFromJsonAsync<CompaniesResponse>();

            // Auto-select company by name only if not already set from restored state
            if (!selectedCompanyId.HasValue || selectedCompanyId == 0)
            {
                selectedCompanyId = companies.Companies?
                    .FirstOrDefault(c => string.Equals(c.Name, autoSelectCompanyName, StringComparison.OrdinalIgnoreCase))
                    ?.Id ?? 0;
            }
        }
    }

    /// <summary>
    /// Fetches all projects from the backend API.
    /// </summary>
    public async Task GetProjects()
    {
        var resp = await Http.GetAsync(api_base + get_proj_endpont);
        if (resp.IsSuccessStatusCode)
        {
            projects = await resp.Content.ReadFromJsonAsync<ProjectsResponse>();
        }
    }

    /// <summary>
    /// Fetches time sheet entries from the backend API based on current filter criteria.
    /// Applies filters for date range, company, category, and project.
    /// Updates the status message with the count of entries found.
    /// Calls GetHoursAndPay() to calculate hours and pay for the filtered results.
    /// </summary>
    public async Task GetEntries()
    {

        SearchParams searchParams = new SearchParams
        {
            Start = Uri.EscapeDataString(start.ToString("yyyy-MM-dd")),
            End = Uri.EscapeDataString(end.ToString("yyyy-MM-dd")),
            Company = selectedCompanyId != 0 ? selectedCompanyId : null,
            Category = selectedCategoryId != 0 ? selectedCategoryId : null,
            Project = selectedProjectId != 0 ? selectedProjectId : null
        };

        try
        {
            var queryParams = new List<string>
            {
                $"start={searchParams.Start}",
                $"end={searchParams.End}"
            };

            if (searchParams.Company.HasValue)
                queryParams.Add($"company_id={searchParams.Company.Value}");
            if (searchParams.Category.HasValue)
                queryParams.Add($"category_id={searchParams.Category.Value}");
            if (searchParams.Project.HasValue)
                queryParams.Add($"project_id={searchParams.Project.Value}");

            var queryString = string.Join("&", queryParams);
            var url = $"{api_base}{get_entries_endpoint}?{queryString}";

            var resp = await Http.GetAsync(url);
            var content = await resp.Content.ReadAsStringAsync();
            if (resp.IsSuccessStatusCode)
            {
                SearchResults = await resp.Content.ReadFromJsonAsync<GetEntriesResponse>();
                label_text = $"Found {SearchResults.Entries?.Count ?? 0} entries.";
            }
            else
            {
                label_text = $"Error: {resp.StatusCode} - {content}";
            }
        }
        catch (Exception ex)
        {
            label_text = $"Error building query: {ex.Message}";
            hide_it = false;
            return;
        }
        hide_it = false;
        await GetHoursAndPay();
    }

    /// <summary>
    /// Calculates total hours and pay for time entries matching the current filter criteria.
    /// Requires that a company is selected. Updates the status message if no company is selected.
    /// </summary>
    private async Task GetHoursAndPay()
    {
        HoursPayResults = new GetHoursAndPayResponse(); // Clear previous results

        SearchParams searchParams = new SearchParams
        {
            Start = Uri.EscapeDataString(start.ToString("yyyy-MM-dd")),
            End = Uri.EscapeDataString(end.ToString("yyyy-MM-dd")),
            Company = selectedCompanyId != 0 ? selectedCompanyId : null,
            Category = selectedCategoryId != 0 ? selectedCategoryId : null,
            Project = selectedProjectId != 0 ? selectedProjectId : null
        };

        if (!searchParams.Company.HasValue)
        {
            label_text = "Please select a company to view hours and pay.";
            hide_it = false;
            return;
        }

        try
        {
            var queryParams = new List<string>
            {
                $"start={searchParams.Start}",
                $"end={searchParams.End}"
            };

            if (searchParams.Company.HasValue)
                queryParams.Add($"company_id={searchParams.Company.Value}");
            if (searchParams.Category.HasValue)
                queryParams.Add($"category_id={searchParams.Category.Value}");
            if (searchParams.Project.HasValue)
                queryParams.Add($"project_id={searchParams.Project.Value}");

            var queryString = string.Join("&", queryParams);
            var url = $"{api_base}{get_hours_pay_endpoint}?{queryString}";

            var resp = await Http.GetAsync(url);
            var content = await resp.Content.ReadAsStringAsync();
            if (resp.IsSuccessStatusCode)
            {
                HoursPayResults = await resp.Content.ReadFromJsonAsync<GetHoursAndPayResponse>();
                //label_text = $"Total Hours: {HoursPayResults.Hours}, Total Pay: {HoursPayResults.Pay:C}";
                StateHasChanged();

            }
            else
            {
                label_text = $"Error: {resp.StatusCode} - {content}";
            }
        }
        catch (Exception ex)
        {
            label_text = $"Error building query: {ex.Message}";
            hide_it = false;
            return;
        }
    }

    /// <summary>
    /// Generates a CSV report of the current time sheet entries and downloads it to the user's device.
    /// The CSV includes date, start time, duration, description, category, and project information.
    /// Also includes total hours in the footer.
    /// </summary>
    private async Task GetReport()
    {
        if (SearchResults.Entries == null || SearchResults.Entries.Count == 0)
        {
            label_text = "No entries to download.";
            hide_it = false;
            return;
        }

        try
        {
            var csv = GenerateCsv(SearchResults.Entries, HoursPayResults);
            var bytes = System.Text.Encoding.UTF8.GetBytes(csv);
            
            await JsRuntime.InvokeVoidAsync("downloadFile", 
                Convert.ToBase64String(bytes), 
                "text/csv", 
                $"timesheet_{DateTime.Now:yyyy-MM-dd_HHmmss}.csv");
            
            label_text = "Report downloaded successfully.";
            hide_it = false;
        }
        catch (Exception ex)
        {
            label_text = $"Error generating report: {ex.Message}";
            hide_it = false;
        }
    }

    /// <summary>
    /// Generates CSV content from a list of time sheet entries.
    /// Properly escapes CSV fields and includes headers and total hours footer.
    /// </summary>
    /// <param name="entries">The list of time sheet entries to convert to CSV.</param>
    /// <param name="hoursPayResults">Optional hours and pay summary to include in footer.</param>
    /// <returns>CSV formatted string with headers, data rows, and footer.</returns>
    private string GenerateCsv(List<Entry> entries, GetHoursAndPayResponse hoursPayResults)
    {
        var sb = new System.Text.StringBuilder();
        
        sb.AppendLine("Date,Start,Minutes,Description,Category,Project");
        
        foreach (var entry in entries)
        {
            var description = EscapeCsvField(entry.Description);
            var category = EscapeCsvField(entry.CategoryCode);
            var project = EscapeCsvField(entry.ProjectCode);
            
            sb.AppendLine($"{entry.EntryDate},{entry.StartTime},{entry.DurationMinutes},{description},{category},{project}");
        }
        
        sb.AppendLine();
        
        if (hoursPayResults != null)
        {
            sb.AppendLine($"Total Hours,{hoursPayResults.Hours}");
        }
        
        return sb.ToString();
    }

    /// <summary>
    /// Escapes a CSV field value by wrapping it in quotes and doubling any internal quotes.
    /// Handles null or empty values by returning an empty quoted string.
    /// </summary>
    /// <param name="value">The field value to escape.</param>
    /// <returns>The escaped CSV field value.</returns>
    private string EscapeCsvField(string value)
    {
        if (string.IsNullOrEmpty(value))
            return "\"\"";
        
        // Always quote fields and escape internal quotes by doubling them
        return "\"" + value.Replace("\"", "\"\"") + "\"";
    }

    /// <summary>
    /// Finds the first Tuesday of the given month.
    /// Used to calculate report due dates.
    /// </summary>
    /// <param name="dateInMonth">Any date within the target month.</param>
    /// <returns>A DateTime representing the first Tuesday of that month.</returns>
    private DateTime GetFirstTuesday(DateTime dateInMonth)
    {
        var firstOfMonth = new DateTime(dateInMonth.Year, dateInMonth.Month, 1);
        
        while (firstOfMonth.DayOfWeek != DayOfWeek.Tuesday)
        {
            firstOfMonth = firstOfMonth.AddDays(1);
        }
        
        return firstOfMonth;
    }

    /// <summary>
    /// Adds a new time sheet entry to the backend.
    /// Validates that required fields are provided, then sends the entry data via API.
    /// Clears the input form and refreshes the entries list upon successful submission.
    /// </summary>
    private async Task AddEntry()
    {
        var entryParams = new InsertEntryParams
        {
            entry_date = date.ToString("yyyy-MM-dd"),
            start_time = time.ToString("HH:mm"),
            duration_minutes = (int)(hours * 60),
            billable = billable ? 1 : 0,
            description = comment,
            category_id = selectedCategoryId != 0 ? selectedCategoryId : null,
            company_id = selectedCompanyId != 0 ? selectedCompanyId : null,
            project_id = selectedProjectId != 0 ? selectedProjectId : null,
            notes = details
        };

        var json = JsonSerializer.Serialize(entryParams);
        var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

        try
        {
            var resp = await Http.PostAsync(api_base + add_entry_endpoint, content);
            var respContent = await resp.Content.ReadAsStringAsync();
            if (resp.IsSuccessStatusCode)
            {
                InsertResults = JsonSerializer.Deserialize<AddEntryResponse>(respContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new AddEntryResponse();
                label_text = $"Entry added with ID: {InsertResults.Inserted}";
            }
            else
            {
                label_text = $"Error: {resp.StatusCode} - {InsertResults.Error}";
            }
        }
        catch (Exception ex)
        {
            label_text = $"Error adding entry: {ex.Message}";
        }

        await GetEntries();
        comment = string.Empty;
        details = string.Empty;
        hours = 0;
    }

    /// <summary>
    /// Updates an existing time sheet entry on the backend.
    /// Validates that required fields are provided before sending the update.
    /// Refreshes the entries list after the update.
    /// </summary>
    /// <param name="entryId">The ID of the entry to update.</param>
    /// <param name="entryDate">The date of the entry (yyyy-MM-dd format).</param>
    /// <param name="startTime">The start time (HH:mm format).</param>
    /// <param name="durationMinutes">The duration in minutes.</param>
    /// <param name="billableValue">1 if billable, 0 if not billable.</param>
    /// <param name="description">Description/comment for the entry.</param>
    /// <param name="categoryId">The category ID (or null).</param>
    /// <param name="companyId">The company ID (or null).</param>
    /// <param name="projectId">The project ID (or null).</param>
    /// <param name="notes">Additional notes for the entry.</param>
    private async Task UpdateEntry(int entryId, string entryDate, string startTime, int durationMinutes, 
        int billableValue, string description, int? categoryId, int? companyId, int? projectId, string notes)
    {
        var updateParams = new UpdateEntryParams
        {
            id = entryId,
            entry_date = entryDate,
            start_time = startTime,
            duration_minutes = durationMinutes,
            billable = billableValue,
            description = description,
            category_id = categoryId,
            company_id = companyId,
            project_id = projectId,
            notes = notes
        };

        var json = JsonSerializer.Serialize(updateParams);
        var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

        try
        {
            var resp = await Http.PostAsync(api_base + update_entry_endpoint, content);
            var respContent = await resp.Content.ReadAsStringAsync();
            if (resp.IsSuccessStatusCode)
            {
                label_text = $"Entry {entryId} updated successfully.";
            }
            else
            {
                label_text = $"Error updating entry: {resp.StatusCode} - {respContent}";
            }
        }
        catch (Exception ex)
        {
            label_text = $"Error updating entry: {ex.Message}";
        }

        hide_it = false;
        await GetEntries();
    }

    /// <summary>
    /// Opens the delete confirmation modal for a specific time sheet entry.
    /// Sets the entryIdToRemove and shows the confirmation dialog.
    /// </summary>
    /// <param name="rem_id">The ID of the entry to remove (optional if already set).</param>
    private async Task RemoveEntry(int rem_id = 0)
    {
        if (rem_id != 0)
        {
            entryIdToRemove = rem_id;
        }

        if (entryIdToRemove == 0)
        {
            label_text = "Please enter a valid entry ID to remove.";
            hide_it = false;
            return;
        }

        deleteItemId = entryIdToRemove;
        deleteItemName = $"Entry #{entryIdToRemove}";
        showDeleteModal = true;
    }

    /// <summary>
    /// Confirms the deletion of a time sheet entry.
    /// Sends the delete request to the backend API and refreshes the entries list.
    /// </summary>
    private async Task ConfirmDelete()
    {
        showDeleteModal = false;

        var payload = new { id = deleteItemId };
        var json = JsonSerializer.Serialize(payload);
        var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

        try
        {
            var resp = await Http.PostAsync(api_base + "removeentry", content);
            var respContent = await resp.Content.ReadAsStringAsync();
            if (resp.IsSuccessStatusCode)
            {
                label_text = $"Entry with ID {deleteItemId} removed.";
            }
            else
            {
                label_text = $"Error: {resp.StatusCode} - {respContent}";
            }
        }
        catch (Exception ex)
        {
            label_text = $"Error removing entry: {ex.Message}";
        }

        await GetEntries();
        hide_it = false;
    }

    /// <summary>
    /// Cancels the deletion operation and closes the delete confirmation modal.
    /// </summary>
    private void CancelDelete()
    {
        showDeleteModal = false;
    }

    /// <summary>
    /// Opens the edit modal dialog for a specific time sheet entry.
    /// Populates the modal form with the entry's current data.
    /// </summary>
    /// <param name="entry">The entry to edit.</param>
    private void OpenEditModal(Entry entry)
    {
        editingEntry = new EditEntryModel
        {
            Id = entry.Id,
            EntryDate = DateTime.Parse(entry.EntryDate),
            StartTime = TimeOnly.Parse(entry.StartTime),
            DurationMinutes = entry.DurationMinutes,
            Description = entry.Description ?? string.Empty,
            CategoryId = entry.CategoryId ?? 0,
            CompanyId = entry.CompanyId ?? 0,
            ProjectId = entry.ProjectId ?? 0,
            Billable = entry.Billable == 1,
            Notes = entry.Notes ?? string.Empty
        };
        showEditModal = true;
    }

    /// <summary>
    /// Closes the edit modal dialog without saving changes.
    /// </summary>
    private void CloseEditModal()
    {
        showEditModal = false;
    }

    /// <summary>
    /// Saves the changes made to a time sheet entry in the edit modal.
    /// Calls UpdateEntry() and then closes the modal.
    /// </summary>
    private async Task SaveEditedEntry()
    {
        await UpdateEntry(
            editingEntry.Id,
            editingEntry.EntryDate.ToString("yyyy-MM-dd"),
            editingEntry.StartTime.ToString("HH:mm"),
            editingEntry.DurationMinutes,
            editingEntry.Billable ? 1 : 0,
            editingEntry.Description,
            editingEntry.CategoryId != 0 ? editingEntry.CategoryId : null,
            editingEntry.CompanyId != 0 ? editingEntry.CompanyId : null,
            editingEntry.ProjectId != 0 ? editingEntry.ProjectId : null,
            editingEntry.Notes
        );
        CloseEditModal();
    }

    /// <summary>
    /// Sets the date and time to the current moment, snapped to the nearest 15-minute interval.
    /// Saves the updated form state to sessionStorage.
    /// </summary>
    private async Task SnapToNow()
    {
        var now = DateTime.Now;
        var minutes = now.Minute;
        var roundedMinutes = (int)Math.Round(minutes / 15.0) * 15;
        
        var snappedTime = now.AddMinutes(roundedMinutes - minutes);
        
        date = snappedTime.Date;
        time = TimeOnly.FromDateTime(snappedTime);
        
        await SaveFormState();
    }

    /// <summary>
    /// Sets the search date range to today only.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task SetToday()
    {
        var today = DateTime.Now.Date;
        start = today;
        end = today;
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Sets the search date range to the current week (Monday to Sunday).
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task SetCurrentWeek()
    {
        var today = DateTime.Now.Date;
        var daysToMonday = (int)today.DayOfWeek - 1;
        var monday = today.AddDays(-daysToMonday);
        var sunday = monday.AddDays(6);
        
        start = monday;
        end = sunday;
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Sets the search date range to the current month (first to last day).
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task SetCurrentMonth()
    {
        var today = DateTime.Now.Date;
        var firstDayOfMonth = new DateTime(today.Year, today.Month, 1);
        var lastDayOfMonth = firstDayOfMonth.AddMonths(1).AddDays(-1);
        
        start = firstDayOfMonth;
        end = lastDayOfMonth;
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Formats a time string for display in human-readable format (h:mm tt).
    /// Handles both datetime strings (with date portion) and time-only strings.
    /// Returns the original string if parsing fails.
    /// </summary>
    /// <param name="timeString">The time string to format (can be "HH:mm", "HH:mm:ss", or "yyyy-MM-dd HH:mm:ss").</param>
    /// <returns>Formatted time string in "h:mm tt" format, or "-" if empty, or original string if parsing fails.</returns>
    private string FormatTime(string timeString)
    {
        if (string.IsNullOrEmpty(timeString))
            return "-";
        
        try
        {
            // Check if it contains a space (likely datetime format like "2024-01-15 14:30:00")
            if (timeString.Contains(" "))
            {
                // Extract just the time portion
                var timePortion = timeString.Split(" ")[1];
                var time = TimeOnly.Parse(timePortion);
                return time.ToString("h:mm tt");
            }
            else
            {
                // Try parsing as just time (HH:mm or HH:mm:ss)
                var time = TimeOnly.Parse(timeString);
                return time.ToString("h:mm tt");
            }
        }
        catch
        {
            return timeString;
        }
    }

    /// <summary>
    /// Parameters for searching and filtering time sheet entries.
    /// Used when constructing API queries.
    /// </summary>
    public class SearchParams
    {
        public string Start { get; set; } = DateTime.Now.ToString("yyyy-MM-dd");
        public string End { get; set; } = DateTime.Now.AddDays(7).ToString("yyyy-MM-dd");
        public int? Company { get; set; }
        public int? Category { get; set; }
        public int? Project { get; set; }
    }

    /// <summary>
    /// Parameters for inserting a new time sheet entry via API.
    /// </summary>
    public class InsertEntryParams
    {
        public string entry_date { get; set; } = DateTime.Now.ToString("yyyy-MM-dd");
        public string start_time { get; set; } = DateTime.Now.ToString("HH:mm");
        public int duration_minutes { get; set; } = 0;
        public int billable { get; set; } = 1;
        public string? description { get; set; }
        public int? category_id { get; set; }
        public int? company_id { get; set; }
        public int? project_id { get; set; }
        public string? notes { get; set; }
    }

    /// <summary>
    /// Parameters for updating an existing time sheet entry via API.
    /// </summary>
    public class UpdateEntryParams
    {
        public int id { get; set; }
        public string entry_date { get; set; } = DateTime.Now.ToString("yyyy-MM-dd");
        public string start_time { get; set; } = DateTime.Now.ToString("HH:mm");
        public int duration_minutes { get; set; } = 0;
        public int billable { get; set; } = 1;
        public string? description { get; set; }
        public int? category_id { get; set; }
        public int? company_id { get; set; }
        public int? project_id { get; set; }
        public string? notes { get; set; }
    }

    /// <summary>
    /// Model for editing a time sheet entry in the edit modal dialog.
    /// </summary>
    public class EditEntryModel
    {
        public int Id { get; set; }
        public DateTime EntryDate { get; set; }
        public TimeOnly StartTime { get; set; }
        public int DurationMinutes { get; set; }
        public string Description { get; set; } = string.Empty;
        public int CategoryId { get; set; }
        public int CompanyId { get; set; }
        public int ProjectId { get; set; }
        public bool Billable { get; set; }
        public string Notes { get; set; } = string.Empty;
    }

    /// <summary>
    /// Saves the current form state to sessionStorage via JavaScript interop.
    /// Persists all form field values so they can be restored if the user navigates away and returns.
    /// </summary>
    private async Task SaveFormState()
    {
        try
        {
            module ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/storage.js");
            
            var state = new
            {
                date = date.ToString("yyyy-MM-dd"),
                time = time.ToString("HH:mm"),
                hours = hours,
                billable = billable,
                comment = comment,
                details = details,
                selectedCategoryId = selectedCategoryId,
                selectedCompanyId = selectedCompanyId,
                selectedProjectId = selectedProjectId,
                start = start.ToString("yyyy-MM-dd"),
                end = end.ToString("yyyy-MM-dd")
            };
            
            await module.InvokeVoidAsync("saveFormState", FORM_STATE_KEY, state);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving form state: {ex.Message}");
        }
    }

    /// <summary>
    /// Loads the previously saved form state from sessionStorage via JavaScript interop.
    /// Restores all form field values to their previous state.
    /// Includes extensive logging for debugging state restoration issues.
    /// </summary>
    private async Task LoadFormState()
    {
        try
        {
            module ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/storage.js");
            
            var stateJson = await module.InvokeAsync<string>("loadFormState", FORM_STATE_KEY);
            
            Console.WriteLine($"[DEBUG] LoadFormState - Retrieved JSON: {stateJson != null}");
            
            if (!string.IsNullOrEmpty(stateJson))
            {
                try
                {
                    using (JsonDocument doc = JsonDocument.Parse(stateJson))
                    {
                        JsonElement root = doc.RootElement;
                        
                        // Parse and restore the state
                        if (root.TryGetProperty("date", out JsonElement dateElem) && dateElem.ValueKind == JsonValueKind.String)
                        {
                            string dateStr = dateElem.GetString();
                            if (DateTime.TryParse(dateStr, out DateTime savedDate))
                            {
                                date = savedDate;
                                Console.WriteLine($"[DEBUG] Restored date: {date}");
                            }
                        }
                        
                        if (root.TryGetProperty("time", out JsonElement timeElem) && timeElem.ValueKind == JsonValueKind.String)
                        {
                            string timeStr = timeElem.GetString();
                            if (TimeOnly.TryParse(timeStr, out TimeOnly savedTime))
                            {
                                time = savedTime;
                                Console.WriteLine($"[DEBUG] Restored time: {time}");
                            }
                        }
                        
                        if (root.TryGetProperty("hours", out JsonElement hoursElem) && hoursElem.ValueKind == JsonValueKind.Number)
                        {
                            if (hoursElem.TryGetSingle(out float savedHours))
                            {
                                hours = savedHours;
                                Console.WriteLine($"[DEBUG] Restored hours: {hours}");
                            }
                        }
                        
                        if (root.TryGetProperty("billable", out JsonElement billableElem) && billableElem.ValueKind == JsonValueKind.True || billableElem.ValueKind == JsonValueKind.False)
                        {
                            billable = billableElem.GetBoolean();
                            Console.WriteLine($"[DEBUG] Restored billable: {billable}");
                        }
                        
                        if (root.TryGetProperty("comment", out JsonElement commentElem) && commentElem.ValueKind == JsonValueKind.String)
                        {
                            comment = commentElem.GetString() ?? string.Empty;
                            Console.WriteLine($"[DEBUG] Restored comment: {comment}");
                        }
                        
                        if (root.TryGetProperty("details", out JsonElement detailsElem) && detailsElem.ValueKind == JsonValueKind.String)
                        {
                            details = detailsElem.GetString() ?? string.Empty;
                            Console.WriteLine($"[DEBUG] Restored details: {details}");
                        }
                        
                        // Parse nullable int values
                        if (root.TryGetProperty("selectedCategoryId", out JsonElement catElem) && catElem.ValueKind == JsonValueKind.Number)
                        {
                            if (catElem.TryGetInt32(out int catId))
                            {
                                selectedCategoryId = catId;
                                Console.WriteLine($"[DEBUG] Restored selectedCategoryId: {selectedCategoryId}");
                            }
                        }
                        
                        if (root.TryGetProperty("selectedCompanyId", out JsonElement compElem) && compElem.ValueKind == JsonValueKind.Number)
                        {
                            if (compElem.TryGetInt32(out int compId))
                            {
                                selectedCompanyId = compId;
                                Console.WriteLine($"[DEBUG] Restored selectedCompanyId: {selectedCompanyId}");
                            }
                        }
                        
                        if (root.TryGetProperty("selectedProjectId", out JsonElement projElem) && projElem.ValueKind == JsonValueKind.Number)
                        {
                            if (projElem.TryGetInt32(out int projId))
                            {
                                selectedProjectId = projId;
                                Console.WriteLine($"[DEBUG] Restored selectedProjectId: {selectedProjectId}");
                            }
                        }
                        
                        if (root.TryGetProperty("start", out JsonElement startElem) && startElem.ValueKind == JsonValueKind.String)
                        {
                            string startStr = startElem.GetString();
                            if (DateTime.TryParse(startStr, out DateTime savedStart))
                            {
                                start = savedStart;
                                Console.WriteLine($"[DEBUG] Restored start: {start}");
                            }
                        }
                        
                        if (root.TryGetProperty("end", out JsonElement endElem) && endElem.ValueKind == JsonValueKind.String)
                        {
                            string endStr = endElem.GetString();
                            if (DateTime.TryParse(endStr, out DateTime savedEnd))
                            {
                                end = savedEnd;
                                Console.WriteLine($"[DEBUG] Restored end: {end}");
                            }
                        }
                    }
                }
                catch (Exception parseEx)
                {
                    Console.WriteLine($"[ERROR] Failed to parse form state JSON: {parseEx.Message}");
                }
            }
            else
            {
                Console.WriteLine("[DEBUG] No form state found in sessionStorage");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] Error loading form state: {ex.Message}");
        }
    }

    /// <summary>
    /// Clears the saved form state from sessionStorage.
    /// Useful for resetting the form to default values or when logging out.
    /// </summary>
    private async Task ClearFormState()
    {
        try
        {
            module ??= await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/storage.js");
            await module.InvokeVoidAsync("clearFormState", FORM_STATE_KEY);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error clearing form state: {ex.Message}");
        }
    }

    /// <summary>
    /// Event handler called when the start date filter is changed.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnStartDateChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the end date filter is changed.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnEndDateChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the category filter is changed.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnCategoryChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the company filter is changed.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnCompanyChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the project filter is changed.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnProjectChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the billable checkbox is toggled.
    /// Saves the form state and refreshes the entries list.
    /// </summary>
    private async Task OnBillableChanged()
    {
        await SaveFormState();
        await GetEntries();
    }

    /// <summary>
    /// Event handler called when the day date input is changed.
    /// Saves the form state without refreshing entries (local change only).
    /// </summary>
    private async Task OnDateChanged()
    {
        await SaveFormState();
    }

    /// <summary>
    /// Event handler called when the time input is changed.
    /// Saves the form state without refreshing entries (local change only).
    /// </summary>
    private async Task OnTimeChanged()
    {
        await SaveFormState();
    }

    /// <summary>
    /// Event handler called when the hours input is changed.
    /// Saves the form state without refreshing entries (local change only).
    /// </summary>
    private async Task OnHoursChanged()
    {
        await SaveFormState();
    }

    /// <summary>
    /// Event handler called when the comment textarea is changed.
    /// Saves the form state without refreshing entries (local change only).
    /// </summary>
    private async Task OnCommentChanged()
    {
        await SaveFormState();
    }

    /// <summary>
    /// Event handler called when the details/notes textarea is changed.
    /// Saves the form state without refreshing entries (local change only).
    /// </summary>
    private async Task OnDetailsChanged()
    {
        await SaveFormState();
    }
}